package com.consumer.weatherapi.WeatherRest;

import com.consumer.weatherapi.WeatherRest.Controller.WeatherMetricController;
import com.consumer.weatherapi.WeatherRest.DTO.MetricQueryRequest;
import com.consumer.weatherapi.WeatherRest.Model.WeatherMetric;
import com.consumer.weatherapi.WeatherRest.Repository.WeatherMetricRepository;
import com.consumer.weatherapi.WeatherRest.Service.WeatherMetricQueryService;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Path;
import jakarta.validation.Validator;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;


import java.lang.reflect.Field;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;


public class WeatherMetricControllerTest {

    private WeatherMetricRepository repository;
    private WeatherMetricQueryService queryService;
    private Validator validator;
    private WeatherMetricController controller;
    private MockMvc mockMvc;


    @BeforeEach
    void setup() {
        repository = mock(WeatherMetricRepository.class);
        queryService = mock(WeatherMetricQueryService.class);
        validator = mock(Validator.class);
        controller = new WeatherMetricController(repository, queryService, validator);
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();

    }

    //  Test for POST /v1/metrics → Successful metric addition
    @Test
    void testAddMetric_Success() throws Exception {
        WeatherMetric inputMetric = new WeatherMetric();
        inputMetric.setSensorId("sensor1");
        inputMetric.setTemperature(22.5);
        inputMetric.setHumidity(60.0);
        inputMetric.setTimestamp(LocalDateTime.of(2025, 4, 4, 14, 30));

        WeatherMetric mockSaved = new WeatherMetric();
        mockSaved.setSensorId("sensor1");
        mockSaved.setTemperature(22.5);
        mockSaved.setHumidity(60.0);
        mockSaved.setTimestamp(LocalDateTime.of(2025, 4, 4, 14, 30));

        // Using reflection to set the ID since it's autogenerated
        Field idField = WeatherMetric.class.getDeclaredField("id");
        idField.setAccessible(true);
        idField.set(mockSaved, 1L);

        when(validator.validate(any())).thenReturn(Collections.emptySet());
        when(repository.save(any())).thenReturn(mockSaved);

        mockMvc.perform(post("/v1/metrics")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                                {
                                  "sensorId": "sensor1",
                                  "temperature": 22.5,
                                  "humidity": 60.0,
                                  "timestamp": "2025-04-04T14:30:00Z"
                                }
                                """))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.metricId").value(1))
                .andExpect(jsonPath("$.sensorId").value("sensor1"))
                .andExpect(jsonPath("$.timestamp[0]").value(2025))
                .andExpect(jsonPath("$.timestamp[1]").value(4))
                .andExpect(jsonPath("$.timestamp[2]").value(4))
                .andExpect(jsonPath("$.timestamp[3]").value(14))
                .andExpect(jsonPath("$.timestamp[4]").value(30));
    }


    //  Test for POST /v1/metrics → Validation failure scenario
    @Test
    void testAddMetric_ValidationFailure() throws Exception {
        WeatherMetric invalidMetric = new WeatherMetric();
        invalidMetric.setSensorId(""); // Invalid input
        invalidMetric.setTemperature(25.5);
        invalidMetric.setHumidity(99);
        invalidMetric.setTimestamp(LocalDateTime.of(2025, 4, 4, 14, 30));

        // Mock constraint violation
        @SuppressWarnings("unchecked")
        ConstraintViolation<WeatherMetric> violation = mock(ConstraintViolation.class);

        // Mock the Path object
        Path path = mock(Path.class);
        when(path.toString()).thenReturn("sensorId");
        when(violation.getPropertyPath()).thenReturn(path);
        when(violation.getMessage()).thenReturn("Sensor ID cannot be blank");

        Set<ConstraintViolation<WeatherMetric>> violations = Set.of(violation);
        when(validator.validate(any(WeatherMetric.class))).thenReturn(violations);

        mockMvc.perform(post("/v1/metrics")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content("""
                                {
                                  "sensorId": "",
                                  "temperature": 25.5,
                                  "humidity": 99,
                                  "timestamp": "2025-04-04T14:30:00"
                                }
                                """))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.sensorId").value("Sensor ID cannot be blank"));
    }


    //  Test for POST /v1/metrics/query-db → Fetching metrics from DB directly
    @Test
    void testQueryMetricsDb_Success() {
        MetricQueryRequest request = new MetricQueryRequest();
        request.setSensorIds(List.of("sensor1"));
        request.setMetrics(List.of("temperature"));
        request.setStatistic("avg");
        request.setStartDate(ZonedDateTime.now().minusDays(1));
        request.setEndDate(ZonedDateTime.now());

        when(queryService.queryMetricsFromDb(any(), any(), any(), any(), any()))
                .thenReturn(List.of());

        ResponseEntity<?> response = controller.queryMetricsDb(request);
        assertEquals(200, response.getStatusCodeValue());
    }

    //  Test for POST /v1/metrics/v1/query → Invalid statistic in request
    @Test
    void testQueryMetrics_InvalidStatistic() {
        MetricQueryRequest request = new MetricQueryRequest();
        request.setSensorIds(List.of("sensor1"));
        request.setMetrics(List.of("temperature"));
        request.setStatistic("invalid"); // Invalid stat

        ResponseEntity<?> response = controller.queryMetrics(request);
        assertEquals(400, response.getStatusCodeValue());
    }

    //  Test for POST /v1/metrics/v1/query → Valid dynamic query (in-memory)
    @Test
    void testQueryMetrics_Success() {
        MetricQueryRequest request = new MetricQueryRequest();
        request.setSensorIds(List.of("sensor1"));
        request.setMetrics(List.of("temperature"));
        request.setStatistic("avg");
        request.setStartDate(ZonedDateTime.now().minusDays(1));
        request.setEndDate(ZonedDateTime.now());

        when(queryService.queryMetrics(request)).thenReturn(Map.of("temperature", 24.0));

        ResponseEntity<?> response = controller.queryMetrics(request);
        assertEquals(200, response.getStatusCodeValue());
    }


}
